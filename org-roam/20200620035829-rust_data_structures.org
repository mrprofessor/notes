#+title: Rust data structures- tags :: [[file:20200619203151-rust.org][Rust]]* Memory in rust** Data memory- For data that are fixed and static.** Stack memory- For data that is declared as variables within a function.** Heap memory- For data that are created at rhe runtime. When data added to this region it's called allocation and freeing is called deallocation.* Calling methods- Unlike fuctions methods are a fuctions associated with a specific data type.** Static methods- Methods that belongs to a type. Can be called =::= operator.** Instance methods- Methods that belongs to an instance of a type are called using the =.= operator.* Error handling*** Graceful error handling(?)- Rust uses =?= operator that automatically does the error handling.#+BEGIN_EXAMPLE rusticlet result = do_something_that_might_fail()?;#+END_EXAMPLEis equivalent to#+BEGIN_EXAMPLE rusticlet result = do_something_that_might_fail();match result {    ok(v) => v,    err(e) => return err(e)}#+end_example- let's see an example#+begin_src rusticfn do_something_that_might_fail(i: i8) -> result<f64, string> {    if i == 42 {        ok(42.0)    } else {        err(string::from("it's not the right number"))    }}fn main() -> result<(), string> {    let result = do_something_that_might_fail(42)?;    println!("result: {}", result);    ok(())}#+end_src#+results:: result: 42*** ugly error handling- =unwrap()= method can be used as an alternative to =?=. it can be used for both =result= and =option=.- it returns the value inside the =result/option=, if err happens then it panics. (=panic!=)#+begin_example rusticmy_option.unwrap()#+end_exampleis equivalent to#+begin_example rusticmatch my_option {    ok(v) => v,    none => panic("some error message generated by rust")}#+end_example*similarly*#+begin_example rusticmy_result.unwrap()#+end_exampleis equivalent to#+begin_example rusticmatch my_result {    ok(v) => v,    err(e) => panic("some error message generated by rust")}#+end_example- let's see an example#+begin_src rusticfn do_something_that_might_fail(i: i8) -> result<f64, string> {    if i == 42 {        return ok(i as f64);    } else {        return err(string::from("it's not the number we want!"));    }}fn main() -> result<(), string> {    let v = do_something_that_might_fail(42).unwrap();    println!("found {}", v);    let e = do_something_that_might_fail(1).unwrap();    println!("found {}", e);    ok(())}/* resultsfound 42thread 'main' panicked at 'called `result::unwrap()` on an `err` value: "it\'s not the number we want!"', src/main.rs:1:340,*/#+end_src#+results:: error: could not compile `cargoprhvtk`.* basic data structures** structures- a structure is a collection of fields. it acts as a blueprint and it doesn't hold any data.*** struct and it's objects#+begin_src rusticstruct seacreature {    animal_type: string,    name: string,    arms: i32,    legs: i32,    weapon: string,}fn main() {    let ferris = seacreature {        animal_type: string::from("crab"),        name: string::from("ferris"),        arms: 2,        legs: 4,        weapon: string::from("claw"),    };    let sarah = seacreature {        animal_type: string::from("octopus"),        name: string::from("sarah"),        arms: 8,        legs: 0,        weapon: string::from("none"),    };    println!(        "{} is a {}. it has {} arms, {} legs, and {} as a weapon!",        ferris.name, ferris.animal_type, ferris.arms, ferris.legs, ferris.weapon    );    println!(        "{} is a {}. it has {} arms, {} legs, and {} as a weapon!",        sarah.name, sarah.animal_type, sarah.arms, sarah.legs, sarah.weapon    );}#+end_src*** tuple like structs#+begin_src rusticstruct location(f32, f32);fn main() {    let loc = location(32.021, 98.421);    println!("location : x - {}, y - {}", loc.0, loc.1);}#+end_src#+results:: location : x - 32.021, y - 98.421*** todo implement this.#+begin_example rustic    /*        let club = [ferris, sarah];        for member in club.iter() {        println!(        "{} is a {}. it has {} arms, {} legs, and {} as a weapon!",        member.name, member.animal_type, member.arms, member.legs, member.weapon    );    }    */#+end_example- todo sdsfs** enumerations- enumerations allow us to create a new type that can have a value of several tagged elements.- enumerations can be created using =enum= keyword.*** enumerations without data#+begin_src rustic#![allow(dead_code)]enum species {    crab,    octopus,    fish,    clam,}struct seacreature {    species: species,    name: string,}fn main() {    let ferris = seacreature {        species: species::crab,        name: string::from("ferris"),    };    match ferris.species {        species::crab => println!("{} is a crab.", ferris.name),        species::octopus => println!("{} is a octopus.", ferris.name),        species::fish => println!("{} is a fish.", ferris.name),        species::clam => println!("{} is a clam.", ferris.name),    }}#+end_src*** enumerations with data#+begin_src rustic#![allow(dead_code)]enum species {    crab,    octopus,    fish,    clam,}enum size {    big,    small,}enum weapon {    claw(i8, size),    none,}struct seacreature {    species: species,    name: string,    weapon: weapon,}fn main() {    let ferris = seacreature {        species: species::crab,        name: string::from("ferris"),        weapon: weapon::claw(2, size::small),        /*weapon: weapon::none,*/    };    match ferris.species {        species::crab => {            println!("{} is a crab.", ferris.name);            match ferris.weapon {                weapon::claw(num_claws, size) => {                    let size_description = match size {                        size::big => "big",                        size::small => "small",                    };                    println!(                        "ferris is a crab with {} {} claws.",                        num_claws, size_description                    );                }                _ => println!("ferris doesn't have any weapons"),            }        }        _ => println!("ferris is some other animal"),    }}#+end_src#+results:: ferris is a crab.: ferris is a crab with 2 small claws.** generic types- generic types in rust allows to partially create structs and enums where the type of the elements can be configurable during compile time.#+begin_src rusticstruct bagofholding<t> {    item: t,}fn main() {    let i32_bag = bagofholding { item: 32 };    /* we can expicitly set the type too */    let i8_bag = bagofholding::<i8> { item: 8 };    let bag_in_a_bag = bagofholding {        item: bagofholding { item: "boom!" },    };    println!(        "{} {} {}",        i32_bag.item, i8_bag.item, bag_in_a_bag.item.item    );}#+end_src#+results:: 32 8 boom!*** built-in generics in rust**** option- rust has a built in generic enum called =option= that allows us to represent =none= and =some=.#+begin_src rusticstruct bagofholding<t> {    item: option<t>,}fn main() {    let i8_bag = bagofholding::<i8> { item: none };    if i8_bag.item.is_none() {        println!("there is nothing in the bag");    } else {        println!("there is something in the bag");    }    let i8_bag = bagofholding::<i8> { item: some(43) };    if i8_bag.item.is_some() {        println!("there is something in the bag");    } else {        println!("there is nothing in the bag");    }    match i8_bag.item {        some(v) => println!("found {} in the bag", v),        none => println!("found nothing in the bag"),    }}#+END_SRC#+RESULTS:: error: Could not compile `cargoJ5wykf`.**** Result:PROPERTIES::ID:       e0a003b4-0ed8-4de5-97fd-f831df7d3c51:END:- =Result= is a generic enum that at allows us to retun an error if occured. It represents =Ok= and =Err=.#+BEGIN_SRC rusticfn something_that_might_fail(i: i8) -> Result<f64, String[[file:20201005100639-lokisay_rust_project.org][lokisay - Rust project]]> {    if i == 42 {        Ok(42.0)    } else {        Err(String::from("This is not the right number"))    }}fn main() {    let result = something_that_might_fail(12);    match result {        Ok(v) => println!("Found {}", v),        Err(e) => println!("Error happened: {}", e),    }}#+END_SRC#+RESULTS:: Error happened: This is not the right number- =main= function can return =Result= too.#+BEGIN_SRC rusticfn something_that_might_fail(i: i8) -> Result<f64, String> {    if i == 42 {        Ok(42.0)    } else {        Err(String::from("This is not the right number"))    }}fn main() -> Result<(), String> {    let result = something_that_might_fail(23);    match result {        Ok(v) => println!("The result is {}", v),        Err(_e) => {            return Err(String::from("Something terrible happened in main"));        }    }    Ok(())}#+END_SRC#+RESULTS:: cargo7iTmRT** Vectors- Vector is a variably sized list of items represented by the struct =Vec=- The macro =vec!= lets us create a vector easily rather than manually constructing one. =let s = vec![23, 43]=- =Vec= has an iterator method =iter()=.- =Vec= internally contains an reference to a fixed list on heap. When the size exceeds it reallocates it's data to a larger sized fixed list.#+BEGIN_SRC rusticfn main() {    let mut i8_vec = Vec::<i8>::new();    i8_vec.push(1);    i8_vec.push(2);    i8_vec.push(3);    for item in i8_vec.iter() {        println!("Item: {}", item);    }    let mut float_vec = Vec::new();    float_vec.push(3.14);    float_vec.push(6.14);    float_vec.push(9.14);    for item in float_vec.iter() {        println!("Item: {}", item);    }    let mut str_vec = vec![String::from("Aloha"), String::from("Hello")];    str_vec.push(String::from("Namaste"));    for item in str_vec.iter() {        println!("Item: {}", item);    }}#+END_SRC#+RESULTS:: Item: 1: Item: 2: Item: 3: Item: 3.14: Item: 6.14: Item: 9.14: Item: Aloha: Item: Hello: Item: Namaste