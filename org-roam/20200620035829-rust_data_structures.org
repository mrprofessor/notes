#+title: Rust data structures- tags :: [[file:20200619203151-rust.org][Rust]]* Basic Data structures** Structures- A structure is a collection of fields. It acts as a blueprint and it doesn't hold any data.*** struct and it's objects#+BEGIN_SRC rusticstruct SeaCreature {    animal_type: String,    name: String,    arms: i32,    legs: i32,    weapon: String,}fn main() {    let ferris = SeaCreature {        animal_type: String::from("crab"),        name: String::from("Ferris"),        arms: 2,        legs: 4,        weapon: String::from("claw"),    };    let sarah = SeaCreature {        animal_type: String::from("octopus"),        name: String::from("Sarah"),        arms: 8,        legs: 0,        weapon: String::from("none"),    };    println!(        "{} is a {}. It has {} arms, {} legs, and {} as a weapon!",        ferris.name, ferris.animal_type, ferris.arms, ferris.legs, ferris.weapon    );    println!(        "{} is a {}. It has {} arms, {} legs, and {} as a weapon!",        sarah.name, sarah.animal_type, sarah.arms, sarah.legs, sarah.weapon    );}#+END_SRC*** Tuple like structs#+BEGIN_SRC rusticstruct Location(f32, f32);fn main() {    let loc = Location(32.021, 98.421);    println!("Location : x - {}, y - {}", loc.0, loc.1);}#+END_SRC#+RESULTS:: Location : x - 32.021, y - 98.421*** TODO Implement this.#+BEGIN_EXAMPLE rustic    /*        let club = [ferris, sarah];        for member in club.iter() {        println!(        "{} is a {}. It has {} arms, {} legs, and {} as a weapon!",        member.name, member.animal_type, member.arms, member.legs, member.weapon    );    }    */#+END_EXAMPLE- TODO sdsfs** Enumerations- Enumerations allow us to create a new type that can have a value of several tagged elements.- Enumerations can be created using =enum= keyword.*** Enumerations without data#+BEGIN_SRC rustic#![allow(dead_code)]enum Species {    Crab,    Octopus,    Fish,    Clam,}struct SeaCreature {    species: Species,    name: String,}fn main() {    let ferris = SeaCreature {        species: Species::Crab,        name: String::from("Ferris"),    };    match ferris.species {        Species::Crab => println!("{} is a crab.", ferris.name),        Species::Octopus => println!("{} is a octopus.", ferris.name),        Species::Fish => println!("{} is a fish.", ferris.name),        Species::Clam => println!("{} is a clam.", ferris.name),    }}#+END_SRC*** Enumerations with data#+BEGIN_SRC rustic#![allow(dead_code)]enum Species {    Crab,    Octopus,    Fish,    Clam,}enum Size {    Big,    Small,}enum Weapon {    Claw(i8, Size),    None,}struct SeaCreature {    species: Species,    name: String,    weapon: Weapon,}fn main() {    let ferris = SeaCreature {        species: Species::Crab,        name: String::from("Ferris"),        weapon: Weapon::Claw(2, Size::Small),        /*weapon: Weapon::None,*/    };    match ferris.species {        Species::Crab => {            println!("{} is a crab.", ferris.name);            match ferris.weapon {                Weapon::Claw(num_claws, size) => {                    let size_description = match size {                        Size::Big => "big",                        Size::Small => "small",                    };                    println!(                        "Ferris is a crab with {} {} claws.",                        num_claws, size_description                    );                }                _ => println!("Ferris doesn't have any weapons"),            }        }        _ => println!("ferris is some other animal"),    }}#+END_SRC#+RESULTS:: Ferris is a crab.: Ferris is a crab with 2 small claws.* Memory in rust** Data memory- For data that are fixed and static.** Stack memory- For data that is declared as variables within a function.** Heap memory- For data that are created at rhe runtime. When data added to this region it's called allocation and freeing is called deallocation.* Calling methods- Unlike fuctions methods are a fuctions associated with a specific data type.** Static methods- Methods that belongs to a type. Can be called =::= operator.** Instance methods- Methods that belongs to an instance of a type are called using the =.= operator.* Generic types