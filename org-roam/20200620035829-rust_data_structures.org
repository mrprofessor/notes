#+title: Rust data structures- tags :: [[file:20200619203151-rust.org][Rust]]* Memory in rust** Data memory- For data that are fixed and static.** Stack memory- For data that is declared as variables within a function.** Heap memory- For data that are created at rhe runtime. When data added to this region it's called allocation and freeing is called deallocation.* Calling methods- Unlike fuctions methods are a fuctions associated with a specific data type.** Static methods- Methods that belongs to a type. Can be called =::= operator.** Instance methods- Methods that belongs to an instance of a type are called using the =.= operator.* Error handling*** Graceful error handling(?)- Rust uses =?= operator that automatically does the error handling.#+BEGIN_EXAMPLE rusticlet result = do_something_that_might_fail()?;#+END_EXAMPLEis equivalent to#+BEGIN_EXAMPLE rusticlet result = do_something_that_might_fail();match result {    Ok(v) => v,    Err(e) => return Err(e)}#+END_EXAMPLE- Let's see an example#+BEGIN_SRC rusticfn do_something_that_might_fail(i: i8) -> Result<f64, String> {    if i == 42 {        Ok(42.0)    } else {        Err(String::from("It's not the right number"))    }}fn main() -> Result<(), String> {    let result = do_something_that_might_fail(42)?;    println!("Result: {}", result);    Ok(())}#+END_SRC#+RESULTS:: Result: 42*** Ugly error handling- =unwrap()= method can be used as an alternative to =?=. It can be used for both =Result= and =Option=.- It returns the value inside the =result/option=, if err happens then it panics. (=panic!=)#+BEGIN_EXAMPLE rusticmy_option.unwrap()#+END_EXAMPLEis equivalent to#+BEGIN_EXAMPLE rusticmatch my_option {    Ok(v) => v,    None => panic("Some error message generated by Rust")}#+END_EXAMPLE*Similarly*#+BEGIN_EXAMPLE rusticmy_result.unwrap()#+END_EXAMPLEis equivalent to#+BEGIN_EXAMPLE rusticmatch my_result {    Ok(v) => v,    Err(e) => panic("Some error message generated by Rust")}#+END_EXAMPLE- Let's see an example#+BEGIN_SRC rusticfn do_something_that_might_fail(i: i8) -> Result<f64, String> {    if i == 42 {        return Ok(i as f64);    } else {        return Err(String::from("It's not the number we want!"));    }}fn main() -> Result<(), String> {    let v = do_something_that_might_fail(42).unwrap();    println!("Found {}", v);    let e = do_something_that_might_fail(1).unwrap();    println!("Found {}", e);    Ok(())}/* ResultsFound 42thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: "It\'s not the number we want!"', src/main.rs:1:340,*/#+END_SRC#+RESULTS:: error: Could not compile `cargopRHvtK`.* Basic Data structures** Structures- A structure is a collection of fields. It acts as a blueprint and it doesn't hold any data.*** struct and it's objects#+BEGIN_SRC rusticstruct SeaCreature {    animal_type: String,    name: String,    arms: i32,    legs: i32,    weapon: String,}fn main() {    let ferris = SeaCreature {        animal_type: String::from("crab"),        name: String::from("Ferris"),        arms: 2,        legs: 4,        weapon: String::from("claw"),    };    let sarah = SeaCreature {        animal_type: String::from("octopus"),        name: String::from("Sarah"),        arms: 8,        legs: 0,        weapon: String::from("none"),    };    println!(        "{} is a {}. It has {} arms, {} legs, and {} as a weapon!",        ferris.name, ferris.animal_type, ferris.arms, ferris.legs, ferris.weapon    );    println!(        "{} is a {}. It has {} arms, {} legs, and {} as a weapon!",        sarah.name, sarah.animal_type, sarah.arms, sarah.legs, sarah.weapon    );}#+END_SRC*** Tuple like structs#+BEGIN_SRC rusticstruct Location(f32, f32);fn main() {    let loc = Location(32.021, 98.421);    println!("Location : x - {}, y - {}", loc.0, loc.1);}#+END_SRC#+RESULTS:: Location : x - 32.021, y - 98.421*** TODO Implement this.#+BEGIN_EXAMPLE rustic    /*        let club = [ferris, sarah];        for member in club.iter() {        println!(        "{} is a {}. It has {} arms, {} legs, and {} as a weapon!",        member.name, member.animal_type, member.arms, member.legs, member.weapon    );    }    */#+END_EXAMPLE- TODO sdsfs** Enumerations- Enumerations allow us to create a new type that can have a value of several tagged elements.- Enumerations can be created using =enum= keyword.*** Enumerations without data#+BEGIN_SRC rustic#![allow(dead_code)]enum Species {    Crab,    Octopus,    Fish,    Clam,}struct SeaCreature {    species: Species,    name: String,}fn main() {    let ferris = SeaCreature {        species: Species::Crab,        name: String::from("Ferris"),    };    match ferris.species {        Species::Crab => println!("{} is a crab.", ferris.name),        Species::Octopus => println!("{} is a octopus.", ferris.name),        Species::Fish => println!("{} is a fish.", ferris.name),        Species::Clam => println!("{} is a clam.", ferris.name),    }}#+END_SRC*** Enumerations with data#+BEGIN_SRC rustic#![allow(dead_code)]enum Species {    Crab,    Octopus,    Fish,    Clam,}enum Size {    Big,    Small,}enum Weapon {    Claw(i8, Size),    None,}struct SeaCreature {    species: Species,    name: String,    weapon: Weapon,}fn main() {    let ferris = SeaCreature {        species: Species::Crab,        name: String::from("Ferris"),        weapon: Weapon::Claw(2, Size::Small),        /*weapon: Weapon::None,*/    };    match ferris.species {        Species::Crab => {            println!("{} is a crab.", ferris.name);            match ferris.weapon {                Weapon::Claw(num_claws, size) => {                    let size_description = match size {                        Size::Big => "big",                        Size::Small => "small",                    };                    println!(                        "Ferris is a crab with {} {} claws.",                        num_claws, size_description                    );                }                _ => println!("Ferris doesn't have any weapons"),            }        }        _ => println!("ferris is some other animal"),    }}#+END_SRC#+RESULTS:: Ferris is a crab.: Ferris is a crab with 2 small claws.** Generic Types- Generic types in Rust allows to partially create structs and enums where the type of the elements can be configurable during compile time.#+BEGIN_SRC rusticstruct BagOfHolding<T> {    item: T,}fn main() {    let i32_bag = BagOfHolding { item: 32 };    /* We can expicitly set the type too */    let i8_bag = BagOfHolding::<i8> { item: 8 };    let bag_in_a_bag = BagOfHolding {        item: BagOfHolding { item: "boom!" },    };    println!(        "{} {} {}",        i32_bag.item, i8_bag.item, bag_in_a_bag.item.item    );}#+END_SRC#+RESULTS:: 32 8 boom!*** Built-in generics in Rust**** Option- Rust has a built in generic enum called =Option= that allows us to represent =None= and =Some=.#+BEGIN_SRC rusticstruct BagOfHolding<T> {    item: Option<T>,}fn main() {    let i8_bag = BagOfHolding::<i8> { item: None };    if i8_bag.item.is_none() {        println!("There is nothing in the bag");    } else {        println!("There is something in the bag");    }    let i8_bag = BagOfHolding::<i8> { item: Some(43) };    if i8_bag.item.is_some() {        println!("There is something in the bag");    } else {        println!("There is nothing in the bag");    }    match i8_bag.item {        Some(v) => println!("Found {} in the bag", v),        None => println!("Found nothing in the bag"),    }}#+END_SRC**** Result- =Result= is a generic enum that at allows us to retun an error if occured. It represents =Ok= and =Err=.#+BEGIN_SRC rusticfn something_that_might_fail(i: i8) -> Result<f64, String> {    if i == 42 {        Ok(42.0)    } else {        Err(String::from("This is not the right number"))    }}fn main() {    let result = something_that_might_fail(12);    match result {        Ok(v) => println!("Found {}", v),        Err(e) => println!("Error happened: {}", e),    }}#+END_SRC#+RESULTS:: Error happened: This is not the right number- =main= function can return =Result= too.#+BEGIN_SRC rusticfn something_that_might_fail(i: i8) -> Result<f64, String> {    if i == 42 {        Ok(42.0)    } else {        Err(String::from("This is not the right number"))    }}fn main() -> Result<(), String> {    let result = something_that_might_fail(23);    match result {        Ok(v) => println!("The result is {}", v),        Err(_e) => {            return Err(String::from("Something terrible happened in main"));        }    }    Ok(())}#+END_SRC#+RESULTS:: cargo7iTmRT** Vectors- Vector is a variably sized list of items represented by the struct =Vec=- The macro =vec!= lets us create a vector easily rather than manually constructing one. =let s = vec![23, 43]=- =Vec= has an iterator method =iter()=.- =Vec= internally contains an reference to a fixed list on heap. When the size exceeds it reallocates it's data to a larger sized fixed list.#+BEGIN_SRC rusticfn main() {    let mut i8_vec = Vec::<i8>::new();    i8_vec.push(1);    i8_vec.push(2);    i8_vec.push(3);    for item in i8_vec.iter() {        println!("Item: {}", item);    }    let mut float_vec = Vec::new();    float_vec.push(3.14);    float_vec.push(6.14);    float_vec.push(9.14);    for item in float_vec.iter() {        println!("Item: {}", item);    }    let mut str_vec = vec![String::from("Aloha"), String::from("Hello")];    str_vec.push(String::from("Namaste"));    for item in str_vec.iter() {        println!("Item: {}", item);    }}#+END_SRC#+RESULTS:: error: Could not compile `cargoPoRcoW`.